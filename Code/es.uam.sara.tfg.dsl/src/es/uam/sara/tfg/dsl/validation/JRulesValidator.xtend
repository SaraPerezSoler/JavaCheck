/*
 * generated by Xtext 2.10.0
 */
package es.uam.sara.tfg.dsl.validation

import org.eclipse.xtext.validation.Check
import javaRule.Rule
import javaRule.Or
import javaRule.And
import javaRule.Interface
import javaRule.Enumeration
import javaRule.Method
import javaRule.JavaRulePackage
import javaRule.NameOperator
import javaRule.JavaDoc
import javaRule.BlendModifiers
import javaRule.AccessModifier
import javaRule.Contains
import javaRule.Attribute
import javaRule.Language
import javaRule.RuleSet
import javaRule.Parameter
import javaRule.NameOperation
import org.eclipse.core.resources.ResourcesPlugin
import javaRule.Quantifier
import javaRule.Element
import javaRule.Sentence
import javaRule.Variable
import javaRule.PrimaryOp
import javaRule.PropertyLiteral
import javaRule.StringVariable
import java.util.List
import javaRule.VariableSubtype
import javaRule.Modifiers
import javaRule.File
import javaRule.RangoNames
import javaRule.Tamanio

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class JRulesValidator extends AbstractJRulesValidator {

	public static val INVALID_SATISFY = 'invalidSatisfy'

	public static val INVALID_IN = 'invalidIn'

//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					JRulesPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	@Check
	def checkProject(RuleSet rs) {
		if (!rs.projectName.isEmpty) {
			var workspace = ResourcesPlugin.getWorkspace().getRoot();
			for (name : rs.projectName) {
				if (name == "") {
					error("The project " + name + " is not into worksapce",
						JavaRulePackage.Literals.RULE_SET__PROJECT_NAME, "invalidProject")
				} else {
					var project = workspace.getProject(name)
					if (!project.exists) {
						error("The project " + name + " is not into worksapce",
							JavaRulePackage.Literals.RULE_SET__PROJECT_NAME, "invalidProject")
					}
				}
			}
		}
	}

	@Check
	def checkSatisfyExists(Rule r) {

		if (((r.eContainer instanceof RuleSet)) && (r.satisfy == null)) {
			error("\"Satisfy\" is required", JavaRulePackage.Literals.RULE__QUANTIFIER, "invalidRule")
		} else if ((r.quantifier == Quantifier.ALL) && (r.satisfy == null)) {
			error("\"Satisfy\" is required with quantifier all", JavaRulePackage.Literals.RULE__QUANTIFIER,
				"invalidRule")
		}
		if ((r.satisfy == null) && (r.filter != null)) {
			error("\"Satisfy\" is required after clause \"which\"", JavaRulePackage.Literals.RULE__FILTER,
				"invalidRule")
		}
	}

	@Check
	def checkTypes(Sentence r) {
		if (r instanceof Rule) {
			if (comprobarPropiedades(r.filter, r.element) == false) {
				error("This filter is not valid for " + r.element.literal.toLowerCase,
					JavaRulePackage.Literals.RULE__FILTER, INVALID_SATISFY);
			}
		}
		for (Variable in : r.in) {
			if (in.element != r.element) {
				error(
					"The clause 'in' must be the same type than the sentences",
					JavaRulePackage.Literals.SENTENCE__IN,
					INVALID_SATISFY
				)
			}
		}
		if (r.from != null) {
			if (r.from.element == Element.ATTRIBUTE || r.from.element == Element.METHOD) {
				error(
					"The clause 'from' can't be attributes or methods",
					JavaRulePackage.Literals.SENTENCE__FROM,
					INVALID_SATISFY
				)
			}
		}

		if (comprobarPropiedades(r.satisfy, r.element) == false) {
			error(
				"This property is not valid for " + r.element.literal.toLowerCase,
				JavaRulePackage.Literals.SENTENCE__SATISFY,
				INVALID_SATISFY
			)
		}
	}

	def boolean comprobarPropiedades(Or or, Element e) {
		var ret = true;
		if (or == null) {
			return true;
		}
		for (And a : or.op) {
			for (PrimaryOp s : a.op) {
				if (s instanceof PropertyLiteral) {
					ret = ret && comprobarSatisfy(e, s.property)
				} else {
					ret = ret && comprobarPropiedades(s as Or, e);
				}
			}
		}
		return ret;
	}

	def comprobarSatisfy(Element e, javaRule.Property s) {
		if ((e == Element.PACKAGE) && (s instanceof javaRule.Package)) {
			return true;
		} else if ((e == Element.INTERFACE) && (s instanceof Interface)) {
			return true;
		} else if ((e == Element.CLASS) && (s instanceof javaRule.Class)) {
			return true;
		} else if ((e == Element.ENUMERATION) && (s instanceof Enumeration)) {
			return true;
		} else if ((e == Element.METHOD) && (s instanceof Method)) {
			return true;
		} else if ((e == Element.ATTRIBUTE) && (s instanceof Attribute)) {
			return true;
		} else if ((e == Element.FILE) && (s instanceof File)) {
			return true;
		} else {
			return false;
		}

	}

	@Check
	def checkStringVariableUsing(Sentence s) {
		if (s.eContainer instanceof RuleSet) {
			var sv = s.eAllContents.toIterable.filter(StringVariable).toList
			for (StringVariable svs : sv) {
				var name = svs.variable.variable.name
				if (svs.variable.subtype != Element.NULL) {
					name += "." + svs.variable.subtype;

					if (!s.using.contain(svs.variable)) {
						error(
							"The variable " + name + " must be declared in 'using' clause  ",
							JavaRulePackage.Literals.SENTENCE__SATISFY
						)
					}
				} else {
					if (!s.using.contain(svs.variable)) {
						if (s.from == null) {
							error(
								"The variable " + name + " must be declared in 'using' or 'from' clause  ",
								JavaRulePackage.Literals.SENTENCE__SATISFY
							)
						}

						if (!s.from.equals(svs.variable.variable)) {
							error(
								"The variable " + name + " must be declared in 'using' or 'from' clause  ",
								JavaRulePackage.Literals.SENTENCE__SATISFY
							)
						}

					}

				}
			}
		}
	}

	def contain(List<VariableSubtype> using, VariableSubtype vs) {
		for (VariableSubtype uvs : using) {
			if (uvs.subtype == vs.subtype && uvs.variable.equals(vs.variable)) {
				return true;
			}
		}
		return false;
	}

	@Check
	def checkUsingOnlyRuleSetSentence(Sentence s) {
		if (!(s.eContainer instanceof RuleSet) && !s.using.isEmpty) {
			error(
				"The 'using' clause must be in the first sentence",
				JavaRulePackage.Literals.SENTENCE__USING,
				INVALID_IN
			)
		}
	}

	@Check
	def checkNameLanguage(NameOperation n) {
		if (n.operator == NameOperator.LIKE && n.language == Language.EMPTY) {
			error(
				"Language must be define for Like operator",
				JavaRulePackage.Literals.NAME_OPERATION__OPERATOR,
				"invalidLanguage"
			)
		}
		if (n.operator != NameOperator.LIKE && n.language != Language.EMPTY) {
			error(
				"Language is only for Like operator",
				JavaRulePackage.Literals.NAME_OPERATION__LANGUAGE,
				"invalidLanguage"
			)
		}
	}

	@Check
	def checkJavaDoc(JavaDoc jd) {

		var s = getSentece(jd);
		if (s.element != Element.METHOD && jd.parameter) {
			warning("The tag @parameter is used for methods", JavaRulePackage.Literals.JAVA_DOC__PARAMETER,
				'inadvisableJavaDoc')
		}
		if (s.element != Element.METHOD && jd.^return) {
			warning("The tag @return is used for methods", JavaRulePackage.Literals.JAVA_DOC__RETURN,
				'inadvisableJavaDoc')
		}
		if (s.element != Element.METHOD && jd.throws) {
			warning("The tag @throws is used for methods", JavaRulePackage.Literals.JAVA_DOC__THROWS,
				'inadvisableJavaDoc')
		}
	}

	def Sentence getSentece(javaRule.Property jd) {
		var conteiner = jd.eContainer
		while (!(conteiner instanceof Sentence)) {
			conteiner = conteiner.eContainer
		}
		return conteiner as Sentence
	}

	@Check
	def checkSubClassOfClass(VariableSubtype vs) {
		if (vs.variable.element == Element.ATTRIBUTE && vs.subtype != Element.NULL) {
			error(
				"Attributes don't have " + vs.subtype.toString.toFirstUpper,
				JavaRulePackage.Literals.VARIABLE_SUBTYPE__SUBTYPE
			)
		}

		if (vs.variable.element == Element.METHOD && vs.subtype != Element.NULL) {
			error(
				"Methods don't have " + vs.subtype.toString.toFirstUpper,
				JavaRulePackage.Literals.VARIABLE_SUBTYPE__SUBTYPE
			)
		}

		if (vs.subtype == Element.FILE || vs.subtype == Element.PACKAGE) {
			error(
				vs.variable.element.toString.toFirstUpper + " don't have " + vs.subtype.toString.toFirstUpper,
				JavaRulePackage.Literals.VARIABLE_SUBTYPE__SUBTYPE
			)
		}
	}

	@Check
	def checkModifiers(BlendModifiers b) {

		var r = getSentece(b.eContainer as Modifiers);

		if (accessPrivateProtecte(b)) {
			if (r.element == Element.CLASS || r.element == Element.INTERFACE || r.element == Element.ENUMERATION) {
				warning("The private and protected modifiers are for classes, interfaces and enumeration internal",
					JavaRulePackage.Literals.BLEND_MODIFIERS__ACCESS, 'inadvisableModifier')
			}
		}
		if (b.abstract) {
			if (r.element == Element.INTERFACE) {
				warning("The interfaces are implicitly abstract, its not necessary add the modifier",
					JavaRulePackage.Literals.BLEND_MODIFIERS__ABSTRACT, 'inadvisableModifier')
			} else if (r.element != Element.CLASS && r.element != Element.METHOD) {
				error("Abstract is for methods and class", JavaRulePackage.Literals.BLEND_MODIFIERS__ABSTRACT,
					'invalidModifier')
			} else if (b.final) {
				error("Methods and Class can't be abstract and final simultaneously",
					JavaRulePackage.Literals.BLEND_MODIFIERS__ABSTRACT, 'invalidModifier')
			}
		}
		if (b.^default) {
			if (r.element != Element.METHOD) {
				error("Only the methods can be default", JavaRulePackage.Literals.BLEND_MODIFIERS__DEFAULT,
					'invalidModifier')
			}
			var sente = getSentenceOrRuleSet(r)
			if (sente instanceof Sentence) {
				if (sente.element != Element.INTERFACE) {
					error("Only the interface have default methods", JavaRulePackage.Literals.BLEND_MODIFIERS__DEFAULT,
						'invalidModifier')
				}
			}
		}

		if (b.final) {
			if (r.element == Element.INTERFACE || r.element == Element.ENUMERATION) {
				error("Final is for methods, class and attributes", JavaRulePackage.Literals.BLEND_MODIFIERS__FINAL,
					'invalidModifier')
			}
		}

		if (b.static) {
			if (r.element == Element.CLASS || r.element == Element.INTERFACE || r.element == Element.ENUMERATION) {
				warning("Static is for classes, interfaces and enumeration internal",
					JavaRulePackage.Literals.BLEND_MODIFIERS__ACCESS, 'inadvisableModifier')
			}
		}
		if (b.synchronized && r.element != Element.METHOD) {
			error("Synchronized is for methods", JavaRulePackage.Literals.BLEND_MODIFIERS__SYNCHRONIZED,
				'invalidModifier')
		}

	}

	def getSentenceOrRuleSet(Sentence s) {
		var container = s.eContainer
		var flag = true;
		while (flag) {
			if (container instanceof Sentence) {
				flag = false;
			} else if (container instanceof RuleSet) {
				flag = false;
			} else {
				container = container.eContainer
			}
		}
		return container

	}

	def accessPrivateProtecte(BlendModifiers b) {
		if (b.access == AccessModifier.PRIVATE || b.access == AccessModifier.PROTECTED) {
			return true;
		}
		return false;
	}

	@Check
	def checkUsing(Sentence s) {
		var using = s.using
		for (VariableSubtype us : using) {
			if (us.subtype != Element.NULL) {
				if (checkExist(us, using) == false && checkExist(us, s.from)==false) {
					error(
						"The variable " + us.variable.name + " must be declared in using clause before " + us.variable.name +
							"." + us.subtype.toString.toFirstUpper, JavaRulePackage.Literals.SENTENCE__USING,
						'invalidModifier')
					}
				}
			}
		}

	def checkExist(VariableSubtype us, Variable from) {
		if (from==null){
			return false;
		}
			if (from.equals(us.variable)){
				return true;
			}
			return false;
		}
		def checkExist(VariableSubtype us, List<VariableSubtype> using) {
			var index = using.indexOf(us);
			for (var i = 0; i < index; i++) {
				if (using.get(i).variable.equals(us.variable) && !using.get(i).equals(us)) {
					return true;
				}
			}
			return false;
		}

		@Check
		def variableNameUnique(Variable v) {
			var ruleSet= getRuleSet(v)
			var variables = ruleSet.eAllContents.toIterable.filter(Variable).toList
				for (Variable v2 : variables) {
					if (!v.equals(v2) && v.name.equals(v2.name)) {
						error("The name " + v.name + " must be unique", JavaRulePackage.Literals.SENTENCE__NAME,
							'invalidModifier')
					}
				}
		}

		@Check
		def checkContains(Contains c) {
			var r = c.rule
			if (r.element == Element.PACKAGE || r.element == Element.FILE) {
				error("This element don't have " + r.element.toString.toFirstUpper,
					JavaRulePackage.Literals.CONTAINS__RULE, "invalidContains")
			}
		}

		@Check
		def checkImplements(RangoNames i) {
			if (i.min < 0) {
				error("The minimum must be greater than 0", JavaRulePackage.Literals.RANGO_NAMES__MIN, 'invalidMin')
			}
			if (i.max < 0) {
				error("The maximum must be greater than 0", JavaRulePackage.Literals.RANGO_NAMES__MAX, 'invalidMin')
			}

			if (i.min > i.max) {
				error("The minimum can't be greater than the maximum", JavaRulePackage.Literals.RANGO_NAMES__MAX,
					'invalidMin')
			}
			if (i.types.size > i.max) {
				error("The number of types can't be greater than the maximum",
					JavaRulePackage.Literals.RANGO_NAMES__MAX, 'invalidMin')
			}
		}

		@Check
		def checkParameters(Parameter p) {
			if (p.exact == -2147483647) {
				if (p.min < 0) {
					error("The minimum must be greater than 0", JavaRulePackage.Literals.PARAMETER__MIN, 'invalidMin')
				}
				if (p.max < 0) {
					error("The maximum must be greater than 0", JavaRulePackage.Literals.PARAMETER__MIN, 'invalidMin')
				}

				if (p.min > p.max) {
					error("The minimum can't be greater than the maximum", JavaRulePackage.Literals.PARAMETER__MIN,
						'invalidMin')
				}
				if (p.types.size > p.max) {
					error("The number of types can't be greater than the maximum",
						JavaRulePackage.Literals.PARAMETER__MAX, 'invalidMin')
				}
			} else {
				if (p.types.size > p.exact) {
					error("The number of types can't be greater than the maximum",
						JavaRulePackage.Literals.PARAMETER__EXACT, 'invalidMin')
				}
			}

		}

		@Check
		def checkTamanio(Tamanio t) {
			if (t.exact == -2147483647) {
				if (t.min < 0) {
					error("The minimum must be greater than 0", JavaRulePackage.Literals.RANGO_NAMES__MIN, 'invalidMin')
				}
				if (t.max < 0) {
					error("The maximum must be greater than 0", JavaRulePackage.Literals.RANGO_NAMES__MAX, 'invalidMin')
				}

				if (t.min > t.max) {
					error("The minimum can't be greater than the maximum", JavaRulePackage.Literals.RANGO_NAMES__MAX,
						'invalidMin')
				}
			}
		}
		
	@Check
	def checkVariableExistsBefore(Sentence s) {
		var in= s.in
		var from= s.from
		var using= s.using;
		
		for (Variable v:in){
			if (!isDeclaredBefore(v, s)){
					error("The variable "+v.name+" must be declared before this sentence", JavaRulePackage.Literals.SENTENCE__IN,
						'invalidMin')
			}
		}
		if (from!=null){
			if (!isDeclaredBefore(from, s)){
				error("The variable "+from.name+" must be declared before this sentence", JavaRulePackage.Literals.SENTENCE__FROM,
							'invalidMin')
			}
		}
		for (VariableSubtype v:using){
			if (!isDeclaredBefore(v.variable, s)){
					error("The variable "+v.variable.name+" must be declared before this sentence", JavaRulePackage.Literals.SENTENCE__IN,
						'invalidMin')
			}
		}
		
		
	}
	
	def boolean isDeclaredBefore(Variable variable, Sentence sentence) {
		var container= getSentenceOrRuleSet(sentence);
		if (container instanceof Sentence){
			isDeclaredBefore(variable, container);
		}else{
			var ruleSet= container as RuleSet	
			for (Sentence s: ruleSet.sentences){
			if (s.equals(sentence)){
				return false;
			}
			if (s.equals(variable)){
				return true;
			}
		}
		return false;
			
		}
		
	}
	
	def RuleSet getRuleSet(Sentence s) {
		var container = s.eContainer
		var flag = true;
		while (flag) {
			if (container instanceof RuleSet) {
				return container
			}
				container = container.eContainer
		}


	}
	}
	