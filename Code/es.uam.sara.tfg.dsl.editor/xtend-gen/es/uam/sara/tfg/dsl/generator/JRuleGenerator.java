/**
 * generated by Xtext 2.9.2
 */
package es.uam.sara.tfg.dsl.generator;

import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class JRuleGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field Rule is undefined"
      + "\nThe method compile(Rule, int) from the type JRuleGenerator refers to the missing type Rule");
  }
  
  public CharSequence compile(final /* Rule */Object rule, final int i) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field Action is undefined"
      + "\nThe method or field ElementJava is undefined"
      + "\nThe method or field ElementJava is undefined"
      + "\nThe method or field ElementJava is undefined"
      + "\nThe method or field ElementJava is undefined"
      + "\nThe method or field ElementJava is undefined"
      + "\nThe method or field ElementJava is undefined"
      + "\naction cannot be resolved"
      + "\n== cannot be resolved"
      + "\nCHECK cannot be resolved"
      + "\non cannot be resolved"
      + "\nelement cannot be resolved"
      + "\nelement cannot be resolved"
      + "\n== cannot be resolved"
      + "\nPACKAGE cannot be resolved"
      + "\npackageImplementacion cannot be resolved"
      + "\non cannot be resolved"
      + "\nelement cannot be resolved"
      + "\nelement cannot be resolved"
      + "\n== cannot be resolved"
      + "\nINTERFACE cannot be resolved"
      + "\ninterfaceImplementacion cannot be resolved"
      + "\non cannot be resolved"
      + "\nelement cannot be resolved"
      + "\nelement cannot be resolved"
      + "\n== cannot be resolved"
      + "\nCLASS cannot be resolved"
      + "\nclassImplementacion cannot be resolved"
      + "\non cannot be resolved"
      + "\nelement cannot be resolved"
      + "\nelement cannot be resolved"
      + "\n== cannot be resolved"
      + "\nENUM cannot be resolved"
      + "\nenumImplementacion cannot be resolved"
      + "\non cannot be resolved"
      + "\nelement cannot be resolved"
      + "\nelement cannot be resolved"
      + "\n== cannot be resolved"
      + "\nMETHOD cannot be resolved"
      + "\nmethodImplementacion cannot be resolved"
      + "\non cannot be resolved"
      + "\nelement cannot be resolved"
      + "\nelement cannot be resolved"
      + "\n== cannot be resolved"
      + "\nATTRIBUTE cannot be resolved"
      + "\nattributeImplementacion cannot be resolved");
  }
  
  public CharSequence packageImplementacion(final /* Rule */Object rule) {
    throw new Error("Unresolved compilation problems:"
      + "\nJavaDoc cannot be resolved to a type."
      + "\nName cannot be resolved to a type."
      + "\nName cannot be resolved to a type."
      + "\nName cannot be resolved to a type."
      + "\nName cannot be resolved to a type."
      + "\nName cannot be resolved to a type."
      + "\nName cannot be resolved to a type."
      + "\nName cannot be resolved to a type."
      + "\nName cannot be resolved to a type."
      + "\nThe method or field NameOperator is undefined"
      + "\non cannot be resolved"
      + "\nsatisfy cannot be resolved"
      + "\nop cannot be resolved"
      + "\nop cannot be resolved"
      + "\nauthor cannot be resolved"
      + "\nparametre cannot be resolved"
      + "\n^return cannot be resolved"
      + "\nversion cannot be resolved"
      + "\nthrows cannot be resolved"
      + "\nsee cannot be resolved"
      + "\ntype cannot be resolved"
      + "\n!= cannot be resolved"
      + "\ntype cannot be resolved"
      + "\noperator cannot be resolved"
      + "\n!= cannot be resolved"
      + "\noperator cannot be resolved"
      + "\n== cannot be resolved"
      + "\nEQUAL cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nlanguage cannot be resolved"
      + "\non cannot be resolved"
      + "\nno cannot be resolved"
      + "\non cannot be resolved"
      + "\nquantifier cannot be resolved");
  }
  
  public CharSequence interfaceImplementacion(final /* Rule */Object rule) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Interfaces inter=new Interfaces(visitors.getInterfaces);");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence classImplementacion(final /* Rule */Object rule) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Classes classes=new Classes(visitors.getClasses);");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence enumImplementacion(final /* Rule */Object rule) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Enumerations enums=new Enumerations (visitors.getEnumerations);");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence methodImplementacion(final /* Rule */Object rule) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Methods methods= new Methods (visitors.getMethods);");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence attributeImplementacion(final /* Rule */Object rule) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Attributes attri= new Attributes (visitors.getAttributes);");
    _builder.newLine();
    return _builder;
  }
}
